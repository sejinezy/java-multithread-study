# java-multithread-study

- 김영한님의 실전 자바 - 고급 1편 (멀티스레드와 동시성) 학습 기록 저장소입니다.
- 챕터 별 핵심 내용을 정리하고, 자동차 경주 게임에 해당 내용을 적용한다면 어떤 방식일지 고민한 과정을 함께 기록합니다.
- 🌐 [강의 바로가기](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)




# 🧠 핵심 내용 정리

## 📚 프로세스와 스레드 소개

- 멀티태스킹과 멀티프로세싱의 가장 큰 차이점은?
    - **하드웨어적 병렬성 유무**
    - 멀티프로세싱은 여러 CPU 코어로 작업을 “물리적”으로 동시에 처리하는 반면, 멀티태스킹은 단일 CPU에서 시간 분할로 동시처럼 보이게 한다. 핵심 차이는 여러 하드웨어(CPU 코어)를 실제로 사용하는가이다.

- 프로세스와 스레드의 메모리 사용 방식에서 가장 중요한 차이는?
    - **프로세스는 독립적 메모리 공간을 가짐**
    - 프로세스는 실행되는 프로그램의 독립적인 인스턴스로 자체 메모리 공간을 가진다. 반면 스레드는 같은 프로세스 내에서 코드, 데이터, 힙 영역을 공유하고 각자 스택만 따로 갖는다.

- 컨텍스트 스위칭이란?
    - **CPU가 작업 상태를 저장/ 복원**
    - 컨텍스트 스위칭은 CPU가 여러 스레드나 프로세스를 번갈아 실행할 때, 이전에 하던 작업의 상태(어디까지 했는지 등)을 저장하고 다음에 할 작업의 상태를 불러오는 과정이다. 이 과정에서 시간이 소요된다.

- 단일 CPU 코어 환경에서 너무 많은 스레드를 사용할 때 비효율적이 될 수 있는 주된 이유는?
    - **컨텍스트 스위칭 비용 증가**
    - 단일 코어에서 스레드가 너무 많으면 CPU가 스레드를 자주 바꿔가며 실행해야 한다. 이때 작업 상태를 저장하고 불러오는 컨텍스트 스위칭 비용이 커져서, 오히려 전체 성능이 떨어질 수 있다.

- I/O 작업이 많은 작업(I/O-bound)에서 스레드 수를 조절할 때, CPU 코어 수와 비교하여 일반적으로 어떻게 하는 것이 효과적일까?
    - **코어 수보다 더 많이 사용**
    - I/O-bound 작업은 CPU가 I/O 완료를 기다리는 시간이 길다. 코어 수보다 스레드를 많이 만들면, 한 스레드가 I/O 대기 중일 때 다른 스레드가 CPU를 사용하여 CPU 활용도를 높일 수 있다.


---
## 📚 스레드 생성과 실행

- 자바 메모리 구조에서, 각 스레드마다 독립적으로 생성되고 관리되는 영역은?
   - **스택 영역**
   - 스택 영역은 각 스레드마다 독립적으로 생성되며, 지역 변수나 메서드 호출 정보를 저장한다. 힙과 메소드 영역은 스레드 간에 공유된다.

- 스레드를 실행할 때, Thread.start() 메소드를 호출하는 것과 run()메소드를 직접 호출하는 것의 가장 중요한 차이점은?
   - **새로운 스레드 생성 여부**
   - start()는 새로운 스레드를 생성하고 OS에 실행을 요청하지만, run() 직접 호출은 단순히 현재 스레드에서 메소드를 실행하는 것과 같다.

- 자바 프로그램의 종료 시점에서 사용자 스레드와 데몬 스레드의 주요 차이점은?
   - **JVM 종료를 막는지 여부**
   - 모든 사용자 스레드가 종료되면 JVM이 종료되지만, 데몬 스레드만 남은 경우 JVM은 기다리지 않고 종료된다. 데몬 스레드는 보조 작업을 수행한다.

- 스레드의 실행할 작업을 정의할 때, Thread 클래스를 상속하는 것보다 Runnable 인터페이스를 구현하는 것을 일반적으로 선호하는 주된 이유는?
   - **다중 상속의 제약 해소**
   - 자바는 단일 상속만 허용하기 때문에, Runnable 구현은 다른 클래스를 상속하면서도 스레드 작업을 정의할 수 있어 더 유연하다.

- 여러 개의 스레드가 동일한 Runnable 인스턴스를 실행 작업으로 사용하는 경우, 각 스레드는 해당 Runnable 인스턴스의 어떤 부분을 각자의 스택에서 실행하게 될까?
   - **run() 메소드 내의 코드**
   - 스레드는 Runnable 인스턴스를 공유하지만, 실제 실행되는 run() 메소드의 코드는 각 스레드의 독립적인 스택 프레임 위에서 실행된다.


### 🚗 자동차 경주에 적용 해보기

| 학습 내용 | 자동차 경주 적용 예시 |
| --- | --- |
| **스레드 생성(start vs run)** | 각 Car를 `Thread.start()`로 실행해야 병렬 |
| **Runnable vs Thread** | Car는 Runnable 구현, RacingGame이 스레드 관리 |
| **데몬 스레드** | 전체 레이스 모니터링용 백그라운드 스레드 가능 |
| **스택 vs 힙** | 각 Car 스레드는 run() 스택 독립, 하지만 cars 리스트는 공유 |
| **컨텍스트 스위칭** | 너무 많은 자동차(스레드)면 CPU 오버헤드 생김 |
| **I/O Bound** | 출력(System.out)은 I/O → 스레드 대기시간 많음 |


---
## 📚 스레드 제어와 생명주기 1

- 스레드를 ‘new Thread()’로 생성만 하고 아직 ‘start()’를 호출하지 않았을 때, 해당 스레드의 초기 상태는?
   - **NEW**
   - ‘new’ 키워드로 스레드 객체만 생성하면 , 아직 ‘start()’를 호출하지 않았기에 실행 대기 상태가 아닌 초기 상태로 남아있다. 스레드의 생명 주기의 첫 단계이다.

- 스레드가 CPU를 사용하며 코드를 실행 중이거나, 실행될 준비를 마치고 OS 스케줄러의 실행 큐에서 대기 중인 상태는?
   - **RUNNABLE**
   - RUNNABLE은 스레드가 실행 가능한 모든 조건을 갖추고 CPU 할당을 기다리거나 현재 실행 중임을 나타낸다. 스레드 라이프사이클의 핵심 실행 단계이다.

- ‘Runnable’ 인터페이스의 ‘run()’ 메소드에서 ‘InterruptedException’ 같은 Checked Exception을 외부에 던질 수 없는 주된 이유는?
   - **오버라이딩 규칙 상 부모 메소드가 선언하지 않은 Checked Exception은 자식 메소드에서 던질 수 없기 때문**
   - ‘Runnable’의 ‘run’ 메소드는 Checked Exception을 선언하지 않았다. 자바 오버라이딩 규칙에 따라, 자식 메소드는 부모가 선언하지 않은 Checked Exception을 던질 수 없다.

- 어떤 스레드 A가 다른 스레드 B의 ‘B.join()’ 메소드를 호출했을 때, 스레드 A는 어떻게 되는지?
   - **스레드 B가 종료될 때까지 기다린다.**
   - ‘join()’을 호출한 스레드 A는 대상 스레드 B가 자신의 작업을 모두 마치고 종료될 때까지 실행을 멈추고 기다린다. 다른 스레드의 완료를 기다릴 때 사용한다.

- ‘thread.join()’ 메소드와 ‘thread.join(long milliseconds)’ 메소드의 가장 큰 차이점은?
   - **하나는 대상 스레드의 작업 완료를 무기한 기다리고, 다른 하나는 지정된 시간만큼만 기다린다.**
   - ‘join()’은 대상 스레드가 끝날 때까지 무한히 기다리는 반면, ‘join(millis)’는 지정된 시간 동안만 기다린다. 시간 초과 시 기다림을 멈추고 다음 코드를 실행한다.


### 🚗 자동차 경주에 적용 해보기

| 학습 내용 | 자동차 경주 적용 예시 | 실제 코드/ 행동 예시 |
| --- | --- | --- |
| **NEW 상태** | 각 자동차(Car)가 생성만 되고 아직 출발하지 않은 단계. 즉, `new Thread(car)`로 객체는 만들어졌지만 레이스가 시작되지 않은 상태. | `Thread t1 = new Thread(new Car(”pobi”));` |
| **RUNNABLE 상태** | 레이스가 “출발” 신호로 start() 호출될 때. 각 Car 스레드가 CPU 할당을 기다리거나 실제로 실행 중 | `t1.start();` |
| **join() 사용** | RaceController가 “모든 자동차가 완주할 때까지 기다린다.” 즉, 메인 스레드가 모든 Car 스레드의 완료를 기다림. | `for(Thread t : threads) { t. join(); }                      printResults(); // 모든 차가 완주하면 결과 출력` |
| **join(long millis)** | “경주 제한 시간”을 설정할 수 있다. 일정 시간만 기다리고, 아직 안 끝난 차는 완주 실패 처리 가능 | `t.join(5000); // 5초 안에 완주 못하면 탈락` |
| **스레드 생명 주기                (NEW → RUNNABLE → TERNIMATED)**     | 각 Car 스레드는 레이스 시작 시 RUNNABLE, 주행이 끝나면 TERNIMATED, 이 생명 주기로 흐름을 관리할 수 있다. | 상태 모니터링 스레드를 추가해서 각 Car 스레드 상태를 주기적으로 출력 |


---
## 📚 스레드 제어와 생명 주기 2

- 스레드 정지를 위해 단순 boolean 플래그를 사용할 때 발생할 수 있는 문제점은?
   - **즉시 응답하지 않고 지연될 수 있다.**
   - 스레드가 sleep같은 블록킹 상태에 있을 때, 플래그를 변경한 다음 while 루프 체크까지 인식하지 못해 정지가 지연될 수 있다. 즉각적인 응답이 어렵다.

- 스레드가 ‘sleep()’ 등으로 대기 중일 때 다른 스레드로부터 ‘interrupt()’ 호출을 받으면 어떻게 되는지?
   - **즉시 깨어나 ‘InterruptedException’이 발생한다.**
   - ‘interrupt()’는 ‘sleep’, ‘join’ 등의 대기 메소드를 즉시 중단시키고 ‘InterruptedException’을 발생시킨다. 이를 통해 대기 상태에서 빠르게 벗어날 수 있다.

- 스레드의 인터럽트 상태를 확인하며, 동시에 그 상태를 해제 (false로 변경)하는 메서드는?
   - **Thread.interrupted()**
   - ‘Thread.interrupted()’ 는 현재 스레드의 인터럽트 상태를 확인하면서, 확인 후 그 상태를 자동으로 false로 초기화해주는 역할을 한다. 자원 정리 등에 유용하다.

- ‘Thread.stop()’ 메서드가 사용 중지된 주된 이유는?
   - **스레드의 자원을 안전하게 정리할 수 없기 때문이다.**
   - ‘Thread.stop()’ 은 언제 어디서 멈출지 예측할 수 없어 스레드가 사용하던 자원을 안전하게 정리할 기회를 주지 않기 때문에 위험하다.

- ‘Thread.yield()’ 와 ‘Thread.sleep()’ 의 가장 큰 차이점은?
   - **‘yield()’ 는 스레드 상태(RUNNABLE)을 유지하고 ‘sleep’ 은 대기 상태(TIMED_WAITED)로 변경한다.**
   - ‘Thread.yield()’ 는 Runnable 상태를 유지하며 잠깐 CPU 사용 기회를 양보하지만, ‘Thread.sleep()’ 은 스레드를 Timed Waiting 상태로 완전히 옮겨 스케줄링에서 제외한다.


### 🚗 자동차 경주에 적용 해보기

- 2주차 자동차 경주 미션은 interrupt()를 필요로 하지 않는다. 하지만 “비상 정지”나 “시간 제한”같은 로직을 추가하게 된다면, interrupt()는 스레드를 안전하게 멈추는 올바른 수단이 된다.

| 학습 내용 | 자동차 경주 적용 예시 | 실제 코드/행동 예시 |
| --- | --- | --- |
| **boolean 플래그로 정지 제어 시 지연 가능** | “모든 자동차 스레드에게 STOP 신호를 보내도, 일부는 아직 sleep 중이거나 연산 중이라 즉시 멈추지 않는다.” ‘플래그 기반 종료’는 반응이 느릴 수 있다. | `while (!stopRequested) { move(); Thread.sleep(100);}                              // sleep 중엔 반응 느림` |
| **interrupt()로 즉시 깨우기** | “경기 긴급 중단” 같은 상황. 심판 스레드가 모든 자동차에게 `interrupt()`호출 → sleep 중인 자동차도 즉시 깨어나고 종료 루틴으로 진입. | `for(Thread carThread : threads) { carThread.interrupt()}` |
| **Thread.interrupted()로 상태 확인 후 정리** | 자동차가 인터럽트를 감지하면 스스로 종료 절차 수행. ‘자원 정리’(예: 결과 저장, 로그 출력 등) 후 안전 종료 가능. | `while (true) { if (Thread.interrupted()) { cleanUp(); break; } move(); }` |
| **Thread.stop() 사용 금지** | “강제 차단”처럼 보이지만 실제론 위험함. 자동차가 주행 중인데 갑자기 stop() 하면 position 갱신 중 데이터 깨짐 가능. (데이터 일관성 깨짐 위험) | ❌ `carThread.stop();` → 쓰지 말 것 |
| **yield() vs sleep()** | 자동차 스레드가 너무 CPU를 독점하지 않도록 잠시 양보할 때는 `yield()` | `java Thread.yield(); // 다른 차에게 실행 기회` |


---
## 📚 메모리 가시성

- 멀티스레드에서 한 스레드가 바꾼 변수 값을 다른 스레드가 바로 못 보는 현상은?
   - **메모리 가시성 문제**
   - 스레드별 캐시 때문에 다른 스레드 변경을 즉시 못 볼 수 있다. 이것을 메모리 가시성 문제라고 한다.

- 멀티스레드 환경에서 메모리 가시성 문제가 생기는 주된 이유는?
   - **CPU 캐시 사용**
   - CPU 코어마다 가진 캐시 메모리가 주 원인이다. 각 스레드가 자신의 캐시에서 읽어와 메인 메모리 동기화가 지연되기 때문이다.

- 자바 ‘volatile’ 키워드가 변수에 보장하는 핵심 기능은?
   - **값 변경의 즉시 가시성**
   - ‘volatile’ 은 해당 변수 읽기를 항상 메인 메모리에서 하도록 강제한다. 덕분에 한 스레드의 변경이 다른 스레드에 바로 보이게 된다.

- ‘volatile’ 사용 시 발생할 수 있는 일반적인 성능 영향은?
   - **성능 저하**
   - 캐시 대신 메인 메모리에 직접 접근해야 해서 성능이 느려질 수 있다. 필요한 경우에만 신중히 사용해야 한다.

- 자바 메모리 모델(JMM)에서 스레드 간 변경 사항 가시성을 보장하는 핵심 개념은?
   - **Happens-Before 관계**
   - Happens-Before 관계는 특정 작업이 다른 작업보다 먼저 일어나고 그 결과가 보장됨을 명시한다. 이는 스레드 간의 변경 가시성을 확실히 해준다.


### 🚗 자동차 경주에 적용 해보기

- **질문** : 각 회차 결과를 실시간으로 출력할 때 volatile을 써야 하나?

   1. 각 Car 스레드가 자기 결과를 직접 출력하는 경우 👉 **volatile 불필요**
      - 출력은 자기 스레드 안에서 바로 수행됨
      - 다른 스레드가 이 값을 읽어서 뭔가 하는 구조가 아님 (공유 데이터 읽기 상황 x)
      - 단지 출력 순서가 뒤섞이는 문제 발생 할 수 있음
  
   2. Car 스레드들이 상태만 갱신, 별도 스레드가 모아서 출력 👉 **volatile 필요 , 혹은 다른 방안 고려**
     - 여러 Car 스레드가 position 업데이트 , 별도 스레드가 주기적으로 positions를 읽어서 라운드 결과 출력 ⇒ 메모리 가시성 문제 발생

- **결론** : volatile은 진짜 공유 필드를 여러 스레드가 동시에 읽고 쓰는 상황에서만 쓰자. 그냥 실시간 출력한다는 이유만으로 쓸 필요는 없다.


---
## 📚 동기화 - synchronized

- 멀티스레딩 환경에서 동시성 문제가 발생하는 주된 원인은?
  - **공유 자원 동시 접근**
  - 여러 스레드가 동일한 공유 자원(예: 객체 필드)에 동시에 접근하고 수정하려 할 때 예측 불가능한 문제가 발생한다. 이는 데이터 불일치로 이어질 수 있다.

- 멀티스레딩 환경에서 동시성 문제가 발생할 위험이 없는 변수는?
  - **지역 변수**
  - 지역 변수는 각 스레드의 고유한 메모리 공간(스택)에 생성되어 다른 스레드와 공유되지 않는다. 따라서 동시성 문제 위험이 없다.

- 여러 스레드가 동시 접근 시 문제가 될 수 있는, 공유 자원을 다루는 코드 부분은 무엇이라 하는가?
  - **임계 영역**
  - 임계 영역은 여러 스레드가 동시에 접근하면 데이터 불일치 등 문제가 생길 수 있는 공유 자원 접근 코드이다. 안전하게 보호되어야 한다.

- ‘synchronized’ 키워드의 주된 역할은?
  - **공유 자원 동시 접근 막기**
  - ‘synchronized’ 는 임계 영역에 대해 객체 잠금을 사용해 한 번에 하나의 스레드만 접근하도록 강제한다. 이를 통해 동시성 문제를 해결한다.

- ‘synchronized’ 사용 시 발생할 수 있는 잠재적 문제는?
  - **성능 저하**
  - ‘synchronized’ 는 스레드 실행을 순차적으로 만들어 병렬성을 제한한다. 임계 영역이 길거나 자주 호출되면 전체적인 성능이 저하될 수 있다.


### 🚗 자동차 경주에 적용해보기

- **“라운드가 진행되면서 움직인다”  VS “전체 움직임을 미리 추첨해두고 나중에 계산한다.”**

  - 1. **라운드가 진행되면서 움직인다.**
     - 라운드 간에는 병렬이 불가능하다.
       - 각 라운드가 이전 결과를 기반으로 업데이트 한다. (데이터 의존성)
       - 예를 들어, Round 2는 Round 1의 위치(position)를 기반으로 다음 이동을 계산 , 또 Round 3은 Round 2 이후 위치 기반으로 계산
       - Round 3이 Round 1보다 먼저 끝날 수 없기 때문에 구조적으로 병렬이 불가능하다.

     - “라운드 내부는 병렬, 라운드 간은 순차”
       - Round 1 → Round 2 → Round 3은 순차
       - 하지만 한 Round 내부에서 각 Car의 move() 연산은 병렬로 수행
       - 이후 RoundResult를 하나로 합쳐서 출력


  - 2. **전체 움직임을 미리 추첨해두고 나중에 계산한다.**
     - “(자동차, 라운드)” 단위 작업을 전부 병렬로 돌려서 결과(이동 여부)를 미리 계산해두고, 나중에 (자동차별 + 라운드) 순서대로 누적해서 출력하는 방식
       - 예를 들어, 자동차 A와 B 두 대가 총 2라운드를 진행한다고 하자.
         - 만드는 태스크 : (A,1), (A,2), (B,1), (B,2)  → 각각 병렬 실행
         - 각 태스크는 “이번 라운드에 이동했는지(0 or 1칸)”만 계산
         - 공유 상태를 전혀 건드리지 않는다 (position 변경 X)
         - 모든 결과를 모아서 (car, round) 기준으로 정렬하고 자동차별로 라운드 순서대로 누적해서 position 계산
         - A-1 라운드 위치 = A(1) 이동 누적
         - A-2 라운드 위치 = A(1)+A(2) 이동 누적
         - B도 마찬가지..
      
       - 이동 여부는 직전 위치와 무관하니 도메인 규칙을 위배하지 않는다.
    
     - **장점** : 공유 상태가 없다.

     - **단점**: 실시간 시뮬레이션 느낌이 줄어든다. 계산이 다 끝난 뒤 재생하는 결과를 보게 된다. 또한 구조가 복잡해진다.


---
## 📚 고급 동기화 - concurrent.Lock

- 스레드가 ‘synchronized’ 블록에 들어가기 위해 기다리는 상태(Blocked)일 때, 인터럽트될 수 있는가?
  - **안된다. 인터럽트를 무시하고 계속 기다린다.**
  - ‘synchronized’ 락을 기다리는 Blocked 상태 스레드는 인터럽트가 발생해도 무시하고 락을 얻을 때까지 무기한 기다린다. LockSupport나 ReentrantLock의 Waiting/Timed Waiting 상태와 큰 차이다.

- ‘LockSupport’ 기능 중, 스레드를 특정 시간 동안만 대기 상태로 만드는 메소드는?
  - **parkNanos()**
  - ‘parkNanos()’는 스레드를 나노초 단위로 지정된 시간만큼만 Timed Waiting 상태로 만든다. 시간이 지나거나 ‘unpark’ 또는 인터럽트 시 깨어난다.

- ‘ReentrantLock’ 사용 시, 락 획득을 시도하고 획득 여부를 기다리지 않고 즉시 알고 싶을 때 사용하는 메소드는?
  - **tryLock()**
  - ‘tryLock()’은 락을 즉시 시도하지 않고 성공 여부를 boolean으로 반환하며 기다리지 않는다. ‘lock()’은 무기한 대기, ‘lockInterruptibly’는 인터럽트 가능한 대기다. ‘unlock’은 락 해제다.

- ‘ReentrantLock’으로 락을 기다리는 동안 인터럽트를 통해 대기를 중단하고 싶은 경우 사용하는 메소드는?
  - **lockInterruptibly()**
  - ‘lockInterruptibly()’는 락을 기다리는 동안 인터럽트가 발생하면 ‘InterruptedException’을 발생시키며 대기를 중단한다. ‘lock()’은 인터럽트를 무시한다. ‘tryLock()’은 기다리지 않거나 시간 제한만 둔다.

- ‘ReentrantLock’의 Fairness 모드를 사용할 때 발생할 수 있는 일반적인 트레이드오프는?
  - **성능 저하**
  - Fairness 모드는 대기 순서를 보장하지만, 락 획득 과정에 추가 오버헤드가 발생해 Non-Fair 모드에 비해 일반적으로 성능이 느려진다. 락 획득 순서 예측 불가능은 Non-Fair 모드의 특징이다.


---
## 📚 생산자 소비자 문제 1

- 생산자 - 소비자 문제에서 다루는 핵심 이슈는?
  - **여러 스레드의 동시 데이터 접근 및 상태 변화 문제**
  - 여러 스레드가 하나의 버퍼를 동시에 사용하면서 발생하는 데이터 접근 및 동기화 문제이다. 생산자와 소비자가 버퍼 상태에 따라 적절히 대기하고 신호해야 한다.

- 생산자 - 소비자 문제에서 버퍼의 역할은?
  - **생산자와 소비자 간 데이터 임시 저장 공간**
  - 생산된 데이터를 소비자가 사용하기 전까지 임시로 보관하는 유한한 공간이다. 스레드들은 이 버퍼를 통해 데이터를 주고 받는다.

- 적절한 대기 메커니즘이 없는 유한 버퍼에서, 생산자가 가득 찬 버퍼에 데이터를 추가하려면 어떻게 될까?
  - **생산자가 데이터를 버린다. (손실)**
  - 버퍼에 공간이 없으므로 데이터를 넣지 못하고 버리게 된다. 이는 데이터 손실로 이어지는 문제다.

- 생산자 - 소비자 문제에서 동기화(Synchronization)가 필요한 주된 이유는?
  - **여러 스레드가 공유 자원(버퍼)에 안전하게 접근하도록 제어**
  - 여러 스레드가 동시에 버퍼에 접근하면 데이터가 꼬이거나 손상될 수 있다. 한 번에 하나의 스레드만 접근하도록 제어하기 위함이다.

- 임계 구역(Critical Section) 내에서 스레드가 락(Lock)을 가진 채로 sleep() 상태에 진입할 때 발생할 수  있는 주요 문제점은?
  - **교착 상태 (Deadlock)**
  - 락을 가진 스레드가 잠들어 버려 다른 스레드가 락을 얻지 못한다. 이로 인해 모두가 영원히 기다리는 교착 상태에 빠질 수 있다.

- Object.wait() 메서드가 현재 스레드가 가진 락(Lock)에 대해 수행하는 주요 동작은?
  - **락을 다른 스레드에게 양보하고 대기한다.**
  - 스레드는 대기 상태로 들어가며, 중요한 것은 이때 보유하고 있던 락을 해제한다는 점이다. 다른 스레드가 락을 얻어 버퍼 상태를 바꿀 수 있게 한다.

- 동기화 컨텍스트 내에서 Object.notify() 메서드의 주된 역할은?
  - **대기 중인 스레드 중 하나를 임의로 선택하여 깨운다.**
  - 같은 객체의 대기 집합(wait set)에서 기다리고 있던 스레드들 중 하나를 깨워 실행 가능 상태로 만든다. 어떤 스레드가 깨어날지는 JVM에 따라 다르다.

- Object.wait()와 Object.notify()를 동기화와 함께 사용하면, 락을 가진 채 대기하는 간단한 메커니즘(sleep 등)에서 발생했던 어떤 주요 문제 해결에 도움이 되는지?
  - **교착 상태 (Deadlock)**
  - wait 호출 시 락을 해제하므로, 대기 중인 스레드가 다른 스레드의 락 획득을 막지 않는다. 따라서 교착 상태를 효과적으로 방지한다.

- 생산자 - 소비자 문제 해결 시, Object.notify()를 사용한 스레드 신호 전달의 중요한 비효율성 중 하나는?
  - **생산자가 소비자를, 소비자가 생산자를 특정하여 깨울 수 없다.**
  - notify는 대기 중인 스레드 중 하나를 임의로 깨운다. 생산자가 소비자를 깨워야 할 때, 대기 중인 생산자를 깨울 수 있어 비효율적이다.

- Object.wait()와 notify()를 사용한 생산자 - 소비자 솔루션이 교착 상태나 데이터 손실을 막았음에도 불구하고, 여전히 비효율적일 수 있는 주된 이유는?
  - **스레드 대기 풀이 하나로 통합되어 있어 특정 타입(생산자/소비자) 스레드만 선택적으로 깨우기 어렵기 때문에**
  - 생산자/소비자 스레드가 하나의 대기 풀을 공유하기 때문이다. notify나 notifyAll로는 특정 타입의 스레드만 선택적으로 깨우기 어려워 불필요한 스레드 깨움이 발생한다.


### 🚗 자동차 경주에 적용해보기

| 학습 내용 | 자동차 경주 적용 예시 | 의미 / 코드 예시 |
| --- | --- | --- |
| **핵심 이슈: 여러 스레드의 동시 접근 문제** | 여러 자동차(Car) 스레드가 동시에 결과를 공유된 결과 큐(result buffer) 에 넣는 상황 | `List<RoundResult>` 같은 결과 리스트에 동시에 추가하면 race condition 발생 가능 |
| **버퍼의 역할: 데이터 임시 저장 공간** | “자동차의 이동 결과(CarPosition)”를 저장해두는 큐(queue) 역할 → 생산자: 자동차, 소비자: 결과 출력 스레드 |  |
| **적절한 대기 메커니즘 없을 경우 문제** | 큐가 꽉 찼을 때 자동차가 계속 결과를 넣으려 하면 데이터 손실 가능 | `queue.offer(result)` → false 시 데이터 버림 |
| **동기화 필요성** | 여러 자동차가 동시에 큐에 넣고, 출력 스레드가 동시에 꺼내는 구조 → 임계 영역 보호 필요 | `synchronized` |
| **임계 구역 내 sleep으로 인한 Deadlock** | 자동차가 큐에 `put()`한 뒤 sleep 중 락을 잡고 있으면, 다른 자동차가 접근 못함 → 교착 상태 | `wait()` / `notify()` 구조로 락 해제해야 함 |
| **wait()의 역할** | 소비자 스레드(출력 스레드)가 큐가 비었을 때 기다림. 자동차 스레드가 새 결과를 넣으면 notify()로 깨움. | `synchronized (queue) { while(queue.isEmpty()) queue.wait(); ... }` |
| **notify()의 역할** | 자동차 스레드가 새로운 결과를 넣었을 때 대기 중인 소비자 스레드를 깨움. | `synchronized (queue) { queue.add(result); queue.notify(); }` |
| **notify()의 비효율성** | 여러 자동차(생산자)가 많고 소비자(출력 스레드)가 하나라면, notifyAll()이 필요할 수 있음. | 비효율적 |
| **전체적 문제 구조** | 자동차: 생산자                                   결과 출력기(심판): 소비자                 버퍼: RoundResult 큐 | 생산자-소비자 모델 매칭 |


---
## 📚 생산자 소비자 문제 2

- 생산자-소비자 문제에서 synchronized/Object를 사용하여 단일 대기 공간을 운영할 때의 주요 비효율성은?
  - **버퍼 상태와 관계없이 임의의 스레드가 깨어날 수 있다.**
  - 단일 대기 공간에서는 생산자가 소비자를, 소비자가 생산자를 깨워야 하지만, 실제로는 데이터 유무와 관계없이 임의의 대기 스레드가 깨어날 수 있어 비효율적이다.

- Lock과 Condition이 synchronized/Object의 단일 대기 공간 한계를 극복할 수 있게 해주는 핵심 기능은?
  - **여러 개의 대기 공간 생성**
  - Lock 인터페이스의 newCondition() 메서드를 사용하면 생산자, 소비자 등 목적에 맞는 여러 개의 Condition 객체를 생성하여 대기 공간을 분리할 수 있다.

- 생산자-소비자 패턴에서 생산자 스레드와 소비자 스레드의 대기 공간을 분리했을 때 얻을 수 있는 주요 이점은?
  - **필요한 스레드만 깨워 효율성을 높인다.**
  - 생산자는 소비자 대기 공간에, 소비자는 생산자 대기 공간에 신호를 보내어 필요한 스레드만 정확하게 깨우므로 불필요한 경쟁과 비효율을 줄일 수 있다.

- BlockingQueue가 비어있는 상태에서 스레드가 블록킹(blocking) 추출(take) 작업을 시도하면 어떻게 되는지?
  - **버퍼에 데이터가 생길 때까지 대기한다.**
  - BlockingQueue의 take() 메서드는 큐가 비어있을 때 즉시 오류를 반환하거나 null을 주는 대신, 데이터가 생길 때까지 해당 스레드를 자동으로 대기 상태로 만든다.

- synchronized 락 획득 대기 스레드(Blocked 상태)와 ReentrantLock의 Condition에서 대기하는 스레드(Waiting 상태)의 주요 차이점 중 하나는?
  - **대기 중 인터럽트 가능성**
  - Synchronized 락 획득 대기(Blocked) 상태는 일반적으로 인터럽트가 불가능하지만, ReentrantLock의 Condition에서 await()로 대기(Waiting)하는 스레드는 인터럽트될 수 있다는 차이가 있다.


### 🚗 자동차 경주에 적용해보기

| 학습 내용 | 자동차 경주 적용 예시 | 의미 / 코드 예시 |
| --- | --- | --- |
| **단일 대기 공간의 비효율성** | synchronized + wait/notify 방식으로 자동차(생산자)가 결과를 넣거나, 출력 스레드(소비자)가 꺼내는 구조를 만들면, 불필요하게 깨어나는 스레드가 생김 | `synchronized(queue){ queue.add(log); queue.notify(); }` → 대기 중인 소비자가 없을 수도 있음 |
| **Lock과 Condition의 핵심 기능** | 생산자용 Condition / 소비자용 Condition을 따로 둘 수 있음. 하지만 직접 구현할 필요 없이, `BlockingQueue`가 내부적으로 이 두 Condition을 관리해줌 | `ArrayBlockingQueue` 내부에는 `notFull`, `notEmpty` 두 Condition 존재 |
| **대기 공간 분리의 이점** | 자동차가 큐가 가득 찼을 때 `notFull.await()`로 정확히 대기하고, 로거가 데이터가 없을 때 `notEmpty.await()`로 대기 → 필요한 스레드만 깨어남 | 불필요한 깨움 감소, 효율 향상 |
| **BlockingQueue가 비어 있을 때 take() 동작** | 출력 스레드(Logger)가 `take()` 호출 시, 큐가 비면 자동으로 대기(Waiting) 상태로 전환 → 바쁜 대기 없음 | `LogEvent ev = queue.take();` |
| **Blocked vs Waiting 상태 차이** | 자동차 스레드가 `put()`에서 대기할 땐 Waiting 상태 (인터럽트 가능) → 필요 시 `interrupt()` 가능 | `catch (InterruptedException e) { Thread.currentThread().interrupt(); }` |
| **Lock & Condition을 직접 쓰지 않아도 되는 이유** | `BlockingQueue` 내부가 이미 Lock/Condition 기반 구현으로 되어 있음. → 직접 `synchronized` 블록을 관리할 필요 없음 | `ArrayBlockingQueue` = ReentrantLock + notFull + notEmpty 조건 큐 |
| **효율적 동작의 본질** | 생산자(자동차)는 버퍼가 꽉 차면 자동 대기, 소비자(Logger)는 버퍼가 비면 자동 대기 → 교착 없이 효율적 협력 | 자동차가 로그 100개 만들어도, 로거가 1개씩만 처리 가능.  |
| **자동차: 생산자 / Logger: 소비자 구조** | 자동차 → `queue.put(LogEvent)` Logger → `queue.take()` 모두 내부 Lock/Condition 구조 활용 | `BlockingQueue<LogEvent> queue = new ArrayBlockingQueue<>(10);` |


---
## 📚 CAS - 동기화와 원자적 연산

- 원자적 연산의 정의는?
  - **나눌 수 없는 단위 작업**
  - 원자적 연산은 중단이나 간섭 없이 한 번에 완전히 실행되는 나눌 수 없는 단위이다. 멀티스레드 안전성의 기본이다.

- ‘i = i + 1’ 같은 연산이 멀티스레드에서 문제되는 이유는?
  - **여러 단계로 나뉘어서**
  - 이 연산은 ‘읽기’, ‘계산’, ‘쓰기’ 여러 단계로 나뉜다. 스레드 간섭이 생기면 예상치 못한 결과가 발생한다.

- ‘volatile’이 ‘i++’를 원자적으로 못 만드는 이유는?
  - **연산 자체를 안 묶어줘서**
  - volatile은 메모리 가시성만 보장한다. 연산이 여러 단계로 나뉜 것 자체를 하나의 원자적 작업으로 만들어주진 않기 때문이다.

- ‘synchronized’가 비원자적 연산 안전성을 보장하는 방식은?
  - **한 스레드만 접근 허용**
  - synchronized는 해당 블록(임계 영역)에 오직 하나의 스레드만 접근하도록 강제한다. 다른 스레드는 기다려야 한다.

- ‘AtomicInteger’ 사용의 주요 이점은?
  - **락 없이 스레드 안전**
  - AtomicInteger는 내부적으로 CAS 같은 기술을 사용하여 개발자가 명시적인 synchronized나 Lock 없이도 안전하게 값을 조작하게 한다.

- CAS(Compare-and-Swap) 연산은 무엇을 가능하게 할까?
  - **락 없이 원자적 변경 시도**
  - CAS는 현재 메모리 값을 확인하고, 기대값과 같으면 원하는 새 값으로 원자적으로 교체한다. 락 기반 방식의 대안이다.

- CAS ‘compareAndSet(기대값, 변경값)’ 핵심 로직은?
  - **값이 같으면 변경 및 성공**
  - CAS는 ‘현재 메모리 값’이 ‘기대값’과 같을 경우에만 값을 ‘변경값’으로 원자적으로 업데이트하고 성공을 알린다.

- 락 방식과 CAS 방식의 주요 차이는?
  - **락-블로킹, CAS-스핀 대기**
  - 락은 획득 실패 시 스레드를 대기/블록 상태로 만들지만, CAS 기반 스핀 락은 락 획득 시도 루프를 돌며 대기한다.

- 충돌이 빈번할 때 CAS(스핀 락) 단점은?
  - **잦은 재시도로 CPU 낭비**
  - 충돌이 잦으면 CAS 연산이 계속 실패하며 while 루프를 반복하게 된다. 이는 CPU 자원을 계속 소모하는 Busy-waiting 상태를 유발한다.

- 스핀 락이 일반 락보다 적합한 때는?
  - **임계 영역이 매우 짧을 때**
  - 스핀 락은 문맥 교환 오버헤드가 없지만 CPU를 소모한다. 임계 영역 실행 시간이 문맥 교환 시간보다 짧을 때 유리하다.


### 🚗 자동차 경주에 적용해보기

| 학습 내용 | 자동차 경주 적용 예시 | 의미 / 코드 예시 |
| --- | --- | --- |
| **원자적 연산: 나눌 수 없는 단위** | 여러 자동차 스레드가 동시에 “경기 중 이동 횟수”나 “전체 라운드 진행 수”를 업데이트할 때, 이 연산이 중간에 끼어들면 안 됨 | `i++` 는 원자적이지 않음 —> `AtomicInteger.incrementAndGet()` 사용 |
| **`i = i + 1` 은 문제된다** | 여러 스레드가 동시에 `totalMoves++` 수행 시 읽기-계산-쓰기 사이에 다른 스레드가 개입 가능 → 결과 손실 | 예: `totalMoves`가 0 → 두 스레드가 동시에 읽으면 둘 다 0, 마지막엔 1만 저장됨 (하나 사라짐) |
| **`volatile`은 가시성만 보장** | `volatile int totalRound` 라 해도 `++` 연산은 여전히 안전하지 않음 | `volatile`은 “읽고 쓰는 순서 보장”까지만 함. 계산은 여전히 분리됨 |
| **`synchronized`로 원자성 확보** | 한 스레드만 진입 → 안전하지만 병렬성 떨어짐 | `synchronized(this){ totalMoves++; }` ⇒ 안전하지만 경쟁 대기 생김 |
| **`AtomicInteger`의 이점** | 여러 자동차 스레드가 동시에 안전하게 이동 횟수 증가 | `AtomicInteger moves = new AtomicInteger(); moves.incrementAndGet();` |
| **CAS(compareAndSet)** | `AtomicInteger` 내부에서 실제 사용하는 메커니즘 → `expect == current`일 때만 값 변경 → 락 없이 원자성 확보 | `while(true){ int cur = value.get(); int next = cur+1; if(value.compareAndSet(cur,next)) break; }` |
| **락 vs CAS 차이** | 자동차들이 같은 결과 리소스에 접근할 때 `synchronized`는 한 명만 통과, CAS는 성공할 때까지 재시도 | `AtomicInteger`는 내부적으로 스핀 대기 (짧은 임계영역이면 효율적) |
| **CAS 단점 (충돌 많을 때)** | 모든 자동차 스레드가 동시에 같은 카운터 업데이트 → 실패 반복으로 CPU 소모 | Thread 수 많을수록 CAS 재시도 빈번 → busy waiting 발생 |
| **스핀 락 적합 조건** | 자동차 경주의 “짧은 임계 영역” (예: 단순 카운터 증가)에는 CAS 유리 | 한 번의 이동 결과 누적처럼 단순한 경우: CAS 빠름, 문맥 교환 불필요 |
| **결론: 락보다 가벼운 CAS, 하지만 무조건은 아니다** | “락 없이 이동 횟수 집계”엔 좋지만, “공유 객체 동시 수정” 같은 복잡한 연산엔 여전히 Lock이 필요 |  |


---
## 📚 동시성 컬렉션

- 일반적인 자바 ‘java.util’ 컬렉션(예: ‘ArrayList’)이 멀티스레드 환경에서 안전하지 않은 주된 이유는?
  - **내부 연산이 원자적이지 않아서**
  - 컬렉션의 ‘add’ 등은 여러 단계로 나뉘어 원자적이지 않다. 멀티스레드 환경에서 이 단계들이 겹치면 데이터 손실이나 손상이 발생할 수 있다.

- ‘Collections.synchronizedList’와 같은 메서드를 사용해 컬렉션을 동기화할 때 발생하는 주요 단점은?
  - **락 범위가 너무 넓다.**
  - 컬렉션 전체에 하나의 락이 걸려 병렬성이 떨어진다. 여러 스레드가 동시에 다른 부분을 사용하려 해도 락 때문에 대기해야 하기 때문이다.

- ‘java.util.concurrent’ 패키지에 있는 동시성 컬렉션의 주된 목적은?
  - **고성능 멀티스레드 환경 지원**
  - 이 패키지의 컬렉션들은 복잡한 동기화 기법을 사용하여 여러 스레드가 효율적으로 동시에 컬렉션에 접근하고 작업할 수 있도록 설계되어있다.

- ‘java.util.concurrent’ 패키지에서 ‘HashMap’의 스레드 안전 대체재로 흔히 사용되는 컬렉션은?
  - **‘ConcurrentHashMap’**
  - ‘ConcurrentHashMap’은 내부적으로 락 분할 등을 통해 높은 동시성을 제공하며 ‘HashMap’과 유사하다. 멀티스레드 환경에서 가장 널리 쓰이는 대용이다.

- 언제 ‘java.util.concurrent’ 패키지의 동시성 컬렉션 대신 일반 ‘java.util’ 컬렉션을 사용하는 것이 더 적절한가?
  - **싱글 스레드 환경일 때**
  - 동시성 컬렉션은 스레드 안전을 위해 오버헤드가 있다. 스레드 안전이 필요 없는 싱글 스레드에서는 오버헤드 없는 일반 컬렉션이 성능상 더 유리하다.


### 🚗 자동차 경주에 적용해보기

| 학습 내용 | 자동차 경주 적용 예시 | 의미 / 코드 예시 |
| --- | --- | --- |
| **일반 컬렉션이 안전하지 않다** | 여러 자동차 스레드가 동시에 `ArrayList`나 `HashMap`에 이동 결과를 추가 → 데이터 유실/충돌 발생 | `List<CarPosition> positions = new ArrayList<>(); // ❌`  여러 스레드가 동시에 add 시, 인덱스 꼬임 가능 |
| **`Collections.synchronizedList` 단점: 락 범위가 넓음** | 각 자동차가 결과 리스트에 로그 추가 시, 전체 리스트에 락이 걸려 병렬성이 크게 떨어짐 | `List<CarPosition> syncList = Collections.synchronizedList(new ArrayList<>());`  한 자동차가 추가 중이면, 다른 스레드 대기 |
| **`java.util.concurrent` 컬렉션의 목적** | 자동차 스레드들이 동시에 결과를 추가해도 락 경합 없이 처리 | 내부적으로 락 분할, CAS, 세그먼트 구조 등으로 구현 → 높은 병렬성 |
| **`ConcurrentHashMap` 사용 예시** | 자동차 이름(key)별 이동 거리(value)를 저장하며 실시간 업데이트 | `ConcurrentHashMap<String, Integer> carPositions = new ConcurrentHashMap<>();`   |
| **싱글 스레드 환경에서는 일반 컬렉션 사용** | 자동차가 하나뿐이거나 라운드 순차 처리 시에는 동시성 컬렉션 불필요 → ArrayList로 충분 | 동시성 컬렉션은 오버헤드 있음. 스레드 한 개면 일반 리스트가 빠름 |