# java-multithread-study

- 김영한님의 실전 자바 - 고급 1편 (멀티스레드와 동시성) 학습 기록 저장소입니다.
- 챕터 별 핵심 내용을 정리하고, 자동차 경주 게임에 해당 내용을 적용한다면 어떤 방식일지 고민한 과정을 함께 기록합니다.
- 🌐 [강의 바로가기](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)




# 🧠 핵심 내용 정리

## 📚 프로세스와 스레드 소개

- 멀티태스킹과 멀티프로세싱의 가장 큰 차이점은?
    - **하드웨어적 병렬성 유무**
    - 멀티프로세싱은 여러 CPU 코어로 작업을 “물리적”으로 동시에 처리하는 반면, 멀티태스킹은 단일 CPU에서 시간 분할로 동시처럼 보이게 한다. 핵심 차이는 여러 하드웨어(CPU 코어)를 실제로 사용하는가이다.

- 프로세스와 스레드의 메모리 사용 방식에서 가장 중요한 차이는?
    - **프로세스는 독립적 메모리 공간을 가짐**
    - 프로세스는 실행되는 프로그램의 독립적인 인스턴스로 자체 메모리 공간을 가진다. 반면 스레드는 같은 프로세스 내에서 코드, 데이터, 힙 영역을 공유하고 각자 스택만 따로 갖는다.

- 컨텍스트 스위칭이란?
    - **CPU가 작업 상태를 저장/ 복원**
    - 컨텍스트 스위칭은 CPU가 여러 스레드나 프로세스를 번갈아 실행할 때, 이전에 하던 작업의 상태(어디까지 했는지 등)을 저장하고 다음에 할 작업의 상태를 불러오는 과정이다. 이 과정에서 시간이 소요된다.

- 단일 CPU 코어 환경에서 너무 많은 스레드를 사용할 때 비효율적이 될 수 있는 주된 이유는?
    - **컨텍스트 스위칭 비용 증가**
    - 단일 코어에서 스레드가 너무 많으면 CPU가 스레드를 자주 바꿔가며 실행해야 한다. 이때 작업 상태를 저장하고 불러오는 컨텍스트 스위칭 비용이 커져서, 오히려 전체 성능이 떨어질 수 있다.

- I/O 작업이 많은 작업(I/O-bound)에서 스레드 수를 조절할 때, CPU 코어 수와 비교하여 일반적으로 어떻게 하는 것이 효과적일까?
    - **코어 수보다 더 많이 사용**
    - I/O-bound 작업은 CPU가 I/O 완료를 기다리는 시간이 길다. 코어 수보다 스레드를 많이 만들면, 한 스레드가 I/O 대기 중일 때 다른 스레드가 CPU를 사용하여 CPU 활용도를 높일 수 있다.


---
## 📚 스레드 생성과 실행

- 자바 메모리 구조에서, 각 스레드마다 독립적으로 생성되고 관리되는 영역은?
   - **스택 영역**
   - 스택 영역은 각 스레드마다 독립적으로 생성되며, 지역 변수나 메서드 호출 정보를 저장한다. 힙과 메소드 영역은 스레드 간에 공유된다.

- 스레드를 실행할 때, Thread.start() 메소드를 호출하는 것과 run()메소드를 직접 호출하는 것의 가장 중요한 차이점은?
   - **새로운 스레드 생성 여부**
   - start()는 새로운 스레드를 생성하고 OS에 실행을 요청하지만, run() 직접 호출은 단순히 현재 스레드에서 메소드를 실행하는 것과 같다.

- 자바 프로그램의 종료 시점에서 사용자 스레드와 데몬 스레드의 주요 차이점은?
   - **JVM 종료를 막는지 여부**
   - 모든 사용자 스레드가 종료되면 JVM이 종료되지만, 데몬 스레드만 남은 경우 JVM은 기다리지 않고 종료된다. 데몬 스레드는 보조 작업을 수행한다.

- 스레드의 실행할 작업을 정의할 때, Thread 클래스를 상속하는 것보다 Runnable 인터페이스를 구현하는 것을 일반적으로 선호하는 주된 이유는?
   - **다중 상속의 제약 해소**
   - 자바는 단일 상속만 허용하기 때문에, Runnable 구현은 다른 클래스를 상속하면서도 스레드 작업을 정의할 수 있어 더 유연하다.

- 여러 개의 스레드가 동일한 Runnable 인스턴스를 실행 작업으로 사용하는 경우, 각 스레드는 해당 Runnable 인스턴스의 어떤 부분을 각자의 스택에서 실행하게 될까?
   - **run() 메소드 내의 코드**
   - 스레드는 Runnable 인스턴스를 공유하지만, 실제 실행되는 run() 메소드의 코드는 각 스레드의 독립적인 스택 프레임 위에서 실행된다.


### 🚗 자동차 경주에 적용 해보기

| 학습 내용 | 자동차 경주 적용 예시 |
| --- | --- |
| **스레드 생성(start vs run)** | 각 Car를 `Thread.start()`로 실행해야 병렬 |
| **Runnable vs Thread** | Car는 Runnable 구현, RacingGame이 스레드 관리 |
| **데몬 스레드** | 전체 레이스 모니터링용 백그라운드 스레드 가능 |
| **스택 vs 힙** | 각 Car 스레드는 run() 스택 독립, 하지만 cars 리스트는 공유 |
| **컨텍스트 스위칭** | 너무 많은 자동차(스레드)면 CPU 오버헤드 생김 |
| **I/O Bound** | 출력(System.out)은 I/O → 스레드 대기시간 많음 |


---
## 📚 스레드 제어와 생명주기 1

- 스레드를 ‘new Thread()’로 생성만 하고 아직 ‘start()’를 호출하지 않았을 때, 해당 스레드의 초기 상태는?
   - **NEW**
   - ‘new’ 키워드로 스레드 객체만 생성하면 , 아직 ‘start()’를 호출하지 않았기에 실행 대기 상태가 아닌 초기 상태로 남아있다. 스레드의 생명 주기의 첫 단계이다.

- 스레드가 CPU를 사용하며 코드를 실행 중이거나, 실행될 준비를 마치고 OS 스케줄러의 실행 큐에서 대기 중인 상태는?
   - **RUNNABLE**
   - RUNNABLE은 스레드가 실행 가능한 모든 조건을 갖추고 CPU 할당을 기다리거나 현재 실행 중임을 나타낸다. 스레드 라이프사이클의 핵심 실행 단계이다.

- ‘Runnable’ 인터페이스의 ‘run()’ 메소드에서 ‘InterruptedException’ 같은 Checked Exception을 외부에 던질 수 없는 주된 이유는?
   - **오버라이딩 규칙 상 부모 메소드가 선언하지 않은 Checked Exception은 자식 메소드에서 던질 수 없기 때문**
   - ‘Runnable’의 ‘run’ 메소드는 Checked Exception을 선언하지 않았다. 자바 오버라이딩 규칙에 따라, 자식 메소드는 부모가 선언하지 않은 Checked Exception을 던질 수 없다.

- 어떤 스레드 A가 다른 스레드 B의 ‘B.join()’ 메소드를 호출했을 때, 스레드 A는 어떻게 되는지?
   - **스레드 B가 종료될 때까지 기다린다.**
   - ‘join()’을 호출한 스레드 A는 대상 스레드 B가 자신의 작업을 모두 마치고 종료될 때까지 실행을 멈추고 기다린다. 다른 스레드의 완료를 기다릴 때 사용한다.

- ‘thread.join()’ 메소드와 ‘thread.join(long milliseconds)’ 메소드의 가장 큰 차이점은?
   - **하나는 대상 스레드의 작업 완료를 무기한 기다리고, 다른 하나는 지정된 시간만큼만 기다린다.**
   - ‘join()’은 대상 스레드가 끝날 때까지 무한히 기다리는 반면, ‘join(millis)’는 지정된 시간 동안만 기다린다. 시간 초과 시 기다림을 멈추고 다음 코드를 실행한다.


### 🚗 자동차 경주에 적용 해보기

| 학습 내용 | 자동차 경주 적용 예시 | 실제 코드/ 행동 예시 |
| --- | --- | --- |
| **NEW 상태** | 각 자동차(Car)가 생성만 되고 아직 출발하지 않은 단계. 즉, `new Thread(car)`로 객체는 만들어졌지만 레이스가 시작되지 않은 상태. | `Thread t1 = new Thread(new Car(”pobi”));` |
| **RUNNABLE 상태** | 레이스가 “출발” 신호로 start() 호출될 때. 각 Car 스레드가 CPU 할당을 기다리거나 실제로 실행 중 | `t1.start();` |
| **join() 사용** | RaceController가 “모든 자동차가 완주할 때까지 기다린다.” 즉, 메인 스레드가 모든 Car 스레드의 완료를 기다림. | `for(Thread t : threads) { t. join(); }                      printResults(); // 모든 차가 완주하면 결과 출력` |
| **join(long millis)** | “경주 제한 시간”을 설정할 수 있다. 일정 시간만 기다리고, 아직 안 끝난 차는 완주 실패 처리 가능 | `t.join(5000); // 5초 안에 완주 못하면 탈락` |
| **스레드 생명 주기                (NEW → RUNNABLE → TERNIMATED)**     | 각 Car 스레드는 레이스 시작 시 RUNNABLE, 주행이 끝나면 TERNIMATED, 이 생명 주기로 흐름을 관리할 수 있다. | 상태 모니터링 스레드를 추가해서 각 Car 스레드 상태를 주기적으로 출력 |


---
## 📚 스레드 제어와 생명 주기 2

- 스레드 정지를 위해 단순 boolean 플래그를 사용할 때 발생할 수 있는 문제점은?
   - **즉시 응답하지 않고 지연될 수 있다.**
   - 스레드가 sleep같은 블록킹 상태에 있을 때, 플래그를 변경한 다음 while 루프 체크까지 인식하지 못해 정지가 지연될 수 있다. 즉각적인 응답이 어렵다.

- 스레드가 ‘sleep()’ 등으로 대기 중일 때 다른 스레드로부터 ‘interrupt()’ 호출을 받으면 어떻게 되는지?
   - **즉시 깨어나 ‘InterruptedException’이 발생한다.**
   - ‘interrupt()’는 ‘sleep’, ‘join’ 등의 대기 메소드를 즉시 중단시키고 ‘InterruptedException’을 발생시킨다. 이를 통해 대기 상태에서 빠르게 벗어날 수 있다.

- 스레드의 인터럽트 상태를 확인하며, 동시에 그 상태를 해제 (false로 변경)하는 메서드는?
   - **Thread.interrupted()**
   - ‘Thread.interrupted()’ 는 현재 스레드의 인터럽트 상태를 확인하면서, 확인 후 그 상태를 자동으로 false로 초기화해주는 역할을 한다. 자원 정리 등에 유용하다.

- ‘Thread.stop()’ 메서드가 사용 중지된 주된 이유는?
   - **스레드의 자원을 안전하게 정리할 수 없기 때문이다.**
   - ‘Thread.stop()’ 은 언제 어디서 멈출지 예측할 수 없어 스레드가 사용하던 자원을 안전하게 정리할 기회를 주지 않기 때문에 위험하다.

- ‘Thread.yield()’ 와 ‘Thread.sleep()’ 의 가장 큰 차이점은?
   - **‘yield()’ 는 스레드 상태(RUNNABLE)을 유지하고 ‘sleep’ 은 대기 상태(TIMED_WAITED)로 변경한다.**
   - ‘Thread.yield()’ 는 Runnable 상태를 유지하며 잠깐 CPU 사용 기회를 양보하지만, ‘Thread.sleep()’ 은 스레드를 Timed Waiting 상태로 완전히 옮겨 스케줄링에서 제외한다.


### 🚗 자동차 경주에 적용 해보기

- 2주차 자동차 경주 미션은 interrupt()를 필요로 하지 않는다. 하지만 “비상 정지”나 “시간 제한”같은 로직을 추가하게 된다면, interrupt()는 스레드를 안전하게 멈추는 올바른 수단이 된다.

| 학습 내용 | 자동차 경주 적용 예시 | 실제 코드/행동 예시 |
| --- | --- | --- |
| **boolean 플래그로 정지 제어 시 지연 가능** | “모든 자동차 스레드에게 STOP 신호를 보내도, 일부는 아직 sleep 중이거나 연산 중이라 즉시 멈추지 않는다.” ‘플래그 기반 종료’는 반응이 느릴 수 있다. | `while (!stopRequested) { move(); Thread.sleep(100);}                              // sleep 중엔 반응 느림` |
| **interrupt()로 즉시 깨우기** | “경기 긴급 중단” 같은 상황. 심판 스레드가 모든 자동차에게 `interrupt()`호출 → sleep 중인 자동차도 즉시 깨어나고 종료 루틴으로 진입. | `for(Thread carThread : threads) { carThread.interrupt()}` |
| **Thread.interrupted()로 상태 확인 후 정리** | 자동차가 인터럽트를 감지하면 스스로 종료 절차 수행. ‘자원 정리’(예: 결과 저장, 로그 출력 등) 후 안전 종료 가능. | `while (true) { if (Thread.interrupted()) { cleanUp(); break; } move(); }` |
| **Thread.stop() 사용 금지** | “강제 차단”처럼 보이지만 실제론 위험함. 자동차가 주행 중인데 갑자기 stop() 하면 position 갱신 중 데이터 깨짐 가능. (데이터 일관성 깨짐 위험) | ❌ `carThread.stop();` → 쓰지 말 것 |
| **yield() vs sleep()** | 자동차 스레드가 너무 CPU를 독점하지 않도록 잠시 양보할 때는 `yield()` | `java Thread.yield(); // 다른 차에게 실행 기회` |


---
## 메모리 가시성

- 멀티스레드에서 한 스레드가 바꾼 변수 값을 다른 스레드가 바로 못 보는 현상은?
   - **메모리 가시성 문제**
   - 스레드별 캐시 때문에 다른 스레드 변경을 즉시 못 볼 수 있다. 이것을 메모리 가시성 문제라고 한다.

- 멀티스레드 환경에서 메모리 가시성 문제가 생기는 주된 이유는?
   - **CPU 캐시 사용**
   - CPU 코어마다 가진 캐시 메모리가 주 원인이다. 각 스레드가 자신의 캐시에서 읽어와 메인 메모리 동기화가 지연되기 때문이다.

- 자바 ‘volatile’ 키워드가 변수에 보장하는 핵심 기능은?
   - **값 변경의 즉시 가시성**
   - ‘volatile’ 은 해당 변수 읽기를 항상 메인 메모리에서 하도록 강제한다. 덕분에 한 스레드의 변경이 다른 스레드에 바로 보이게 된다.

- ‘volatile’ 사용 시 발생할 수 있는 일반적인 성능 영향은?
   - **성능 저하**
   - 캐시 대신 메인 메모리에 직접 접근해야 해서 성능이 느려질 수 있다. 필요한 경우에만 신중히 사용해야 한다.

- 자바 메모리 모델(JMM)에서 스레드 간 변경 사항 가시성을 보장하는 핵심 개념은?
   - **Happens-Before 관계**
   - Happens-Before 관계는 특정 작업이 다른 작업보다 먼저 일어나고 그 결과가 보장됨을 명시한다. 이는 스레드 간의 변경 가시성을 확실히 해준다.


### 🚗 자동차 경주에 적용 해보기

- **질문** : 각 회차 결과를 실시간으로 출력할 때 volatile을 써야 하나?

   1. 각 Car 스레드가 자기 결과를 직접 출력하는 경우 👉 **volatile 불필요**
      - 출력은 자기 스레드 안에서 바로 수행됨
      - 다른 스레드가 이 값을 읽어서 뭔가 하는 구조가 아님 (공유 데이터 읽기 상황 x)
      - 단지 출력 순서가 뒤섞이는 문제 발생 할 수 있음
  
   2. Car 스레드들이 상태만 갱신, 별도 스레드가 모아서 출력 👉 **volatile 필요 , 혹은 다른 방안 고려**
     - 여러 Car 스레드가 position 업데이트 , 별도 스레드가 주기적으로 positions를 읽어서 라운드 결과 출력 ⇒ 메모리 가시성 문제 발생

- **결론** : volatile은 진짜 공유 필드를 여러 스레드가 동시에 읽고 쓰는 상황에서만 쓰자. 그냥 실시간 출력한다는 이유만으로 쓸 필요는 없다.


---
## 동기화 - synchronized

- 멀티스레딩 환경에서 동시성 문제가 발생하는 주된 원인은?
  - **공유 자원 동시 접근**
  - 여러 스레드가 동일한 공유 자원(예: 객체 필드)에 동시에 접근하고 수정하려 할 때 예측 불가능한 문제가 발생한다. 이는 데이터 불일치로 이어질 수 있다.

- 멀티스레딩 환경에서 동시성 문제가 발생할 위험이 없는 변수는?
  - **지역 변수**
  - 지역 변수는 각 스레드의 고유한 메모리 공간(스택)에 생성되어 다른 스레드와 공유되지 않는다. 따라서 동시성 문제 위험이 없다.

- 여러 스레드가 동시 접근 시 문제가 될 수 있는, 공유 자원을 다루는 코드 부분은 무엇이라 하는가?
  - **임계 영역**
  - 임계 영역은 여러 스레드가 동시에 접근하면 데이터 불일치 등 문제가 생길 수 있는 공유 자원 접근 코드이다. 안전하게 보호되어야 한다.

- ‘synchronized’ 키워드의 주된 역할은?
  - **공유 자원 동시 접근 막기**
  - ‘synchronized’ 는 임계 영역에 대해 객체 잠금을 사용해 한 번에 하나의 스레드만 접근하도록 강제한다. 이를 통해 동시성 문제를 해결한다.

- ‘synchronized’ 사용 시 발생할 수 있는 잠재적 문제는?
  - **성능 저하**
  - ‘synchronized’ 는 스레드 실행을 순차적으로 만들어 병렬성을 제한한다. 임계 영역이 길거나 자주 호출되면 전체적인 성능이 저하될 수 있다.


### 🚗 자동차 경주에 적용해보기

- **“라운드가 진행되면서 움직인다”  VS “전체 움직임을 미리 추첨해두고 나중에 계산한다.”**

  - 1. **라운드가 진행되면서 움직인다.**
     - 라운드 간에는 병렬이 불가능하다.
       - 각 라운드가 이전 결과를 기반으로 업데이트 한다. (데이터 의존성)
       - 예를 들어, Round 2는 Round 1의 위치(position)를 기반으로 다음 이동을 계산 , 또 Round 3은 Round 2 이후 위치 기반으로 계산
       - Round 3이 Round 1보다 먼저 끝날 수 없기 때문에 구조적으로 병렬이 불가능하다.

     - “라운드 내부는 병렬, 라운드 간은 순차”
       - Round 1 → Round 2 → Round 3은 순차
       - 하지만 한 Round 내부에서 각 Car의 move() 연산은 병렬로 수행
       - 이후 RoundResult를 하나로 합쳐서 출력

  - 2. **전체 움직임을 미리 추첨해두고 나중에 계산한다.**
     - “(자동차, 라운드)” 단위 작업을 전부 병렬로 돌려서 결과(이동 여부)를 미리 계산해두고, 나중에 (자동차별 + 라운드) 순서대로 누적해서 출력하는 방식
       - 예를 들어, 자동차 A와 B 두 대가 총 2라운드를 진행한다고 하자.
         - 만드는 태스크 : (A,1), (A,2), (B,1), (B,2)  → 각각 병렬 실행
         - 각 태스크는 “이번 라운드에 이동했는지(0 or 1칸)”만 계산
         - 공유 상태를 전혀 건드리지 않는다 (position 변경 X)
         - 모든 결과를 모아서 (car, round) 기준으로 정렬하고 자동차별로 라운드 순서대로 누적해서 position 계산
         - A-1 라운드 위치 = A(1) 이동 누적
         - A-2 라운드 위치 = A(1)+A(2) 이동 누적
         - B도 마찬가지..
      
       - 이동 여부는 직전 위치와 무관하니 도메인 규칙을 위배하지 않는다.
    
     - **장점** : 공유 상태가 없다.

     - **단점**: 실시간 시뮬레이션 느낌이 줄어든다. 계산이 다 끝난 뒤 재생하는 결과를 보게 된다. 또한 구조가 복잡해진다.