# java-multithread-study

- 김영한님의 실전 자바 - 고급 1편 (멀티스레드와 동시성) 학습 기록 저장소입니다.
- https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard



## 핵심 내용 정리

### 프로세스와 스레드 소개

1. 멀티태스킹과 멀티프로세싱의 가장 큰 차이점은?
    - **하드웨어적 병렬성 유무**
    - 멀티프로세싱은 여러 CPU 코어로 작업을 “물리적”으로 동시에 처리하는 반면, 멀티태스킹은 단일 CPU에서 시간 분할로 동시처럼 보이게 한다. 핵심 차이는 여러 하드웨어(CPU 코어)를 실제로 사용하는가이다.

2. 프로세스와 스레드의 메모리 사용 방식에서 가장 중요한 차이는?
    - **프로세스는 독립적 메모리 공간을 가짐**
    - 프로세스는 실행되는 프로그램의 독립적인 인스턴스로 자체 메모리 공간을 가진다. 반면 스레드는 같은 프로세스 내에서 코드, 데이터, 힙 영역을 공유하고 각자 스택만 따로 갖는다.

3. 컨텍스트 스위칭이란?
    - **CPU가 작업 상태를 저장/ 복원**
    - 컨텍스트 스위칭은 CPU가 여러 스레드나 프로세스를 번갈아 실행할 때, 이전에 하던 작업의 상태(어디까지 했는지 등)을 저장하고 다음에 할 작업의 상태를 불러오는 과정이다. 이 과정에서 시간이 소요된다.

4. 단일 CPU 코어 환경에서 너무 많은 스레드를 사용할 때 비효율적이 될 수 있는 주된 이유는?
    - **컨텍스트 스위칭 비용 증가**
    - 단일 코어에서 스레드가 너무 많으면 CPU가 스레드를 자주 바꿔가며 실행해야 한다. 이때 작업 상태를 저장하고 불러오는 컨텍스트 스위칭 비용이 커져서, 오히려 전체 성능이 떨어질 수 있다.

5. I/O 작업이 많은 작업(I/O-bound)에서 스레드 수를 조절할 때, CPU 코어 수와 비교하여 일반적으로 어떻게 하는 것이 효과적일까?
    - **코어 수보다 더 많이 사용**
    - I/O-bound 작업은 CPU가 I/O 완료를 기다리는 시간이 길다. 코어 수보다 스레드를 많이 만들면, 한 스레드가 I/O 대기 중일 때 다른 스레드가 CPU를 사용하여 CPU 활용도를 높일 수 있다.


---
### 스레드 생성과 실행

1. 자바 메모리 구조에서, 각 스레드마다 독립적으로 생성되고 관리되는 영역은?
   - **스택 영역**
   - 스택 영역은 각 스레드마다 독립적으로 생성되며, 지역 변수나 메서드 호출 정보를 저장한다. 힙과 메소드 영역은 스레드 간에 공유된다.

2. 스레드를 실행할 때, Thread.start() 메소드를 호출하는 것과 run()메소드를 직접 호출하는 것의 가장 중요한 차이점은?
   - **새로운 스레드 생성 여부**
   - start()는 새로운 스레드를 생성하고 OS에 실행을 요청하지만, run() 직접 호출은 단순히 현재 스레드에서 메소드를 실행하는 것과 같다.

3. 자바 프로그램의 종료 시점에서 사용자 스레드와 데몬 스레드의 주요 차이점은?
   - **JVM 종료를 막는지 여부**
   - 모든 사용자 스레드가 종료되면 JVM이 종료되지만, 데몬 스레드만 남은 경우 JVM은 기다리지 않고 종료된다. 데몬 스레드는 보조 작업을 수행한다.

4. 스레드의 실행할 작업을 정의할 때, Thread 클래스를 상속하는 것보다 Runnable 인터페이스를 구현하는 것을 일반적으로 선호하는 주된 이유는?
   - **다중 상속의 제약 해소**
   - 자바는 단일 상속만 허용하기 때문에, Runnable 구현은 다른 클래스를 상속하면서도 스레드 작업을 정의할 수 있어 더 유연하다.

5. 여러 개의 스레드가 동일한 Runnable 인스턴스를 실행 작업으로 사용하는 경우, 각 스레드는 해당 Runnable 인스턴스의 어떤 부분을 각자의 스택에서 실행하게 될까?
   - **run() 메소드 내의 코드**
   - 스레드는 Runnable 인스턴스를 공유하지만, 실제 실행되는 run() 메소드의 코드는 각 스레드의 독립적인 스택 프레임 위에서 실행된다.


| 지금 배운 내용 | 자동차 경주 적용 예시 |
| --- | --- |
| **스레드 생성(start vs run)** | 각 Car를 Thread.start()로 실행해야 병렬 |
| **Runnable vs Thread** | Car는 Runnable 구현, RacingGame이 스레드 관리 |
| **데몬 스레드** | 전체 레이스 모니터링용 백그라운드 스레드 가능 |
| **스택 vs 힙** | 각 Car 스레드는 run() 스택 독립, 하지만 cars 리스트는 공유 |
| **컨텍스트 스위칭** | 너무 많은 자동차(스레드)면 CPU 오버헤드 생김 |
| **I/O Bound** | 출력(System.out)은 I/O → 스레드 대기시간 많음 |


---
### 스레드 제어와 생명주기 1

1. 스레드를 ‘new Thread()’로 생성만 하고 아직 ‘start()’를 호출하지 않았을 때, 해당 스레드의 초기 상태는?
   - **NEW**
   - ‘new’ 키워드로 스레드 객체만 생성하면 , 아직 ‘start()’를 호출하지 않았기에 실행 대기 상태가 아닌 초기 상태로 남아있다. 스레드의 생명 주기의 첫 단계이다.

2. 스레드가 CPU를 사용하며 코드를 실행 중이거나, 실행될 준비를 마치고 OS 스케줄러의 실행 큐에서 대기 중인 상태는?
   - **RUNNABLE**
   - RUNNABLE은 스레드가 실행 가능한 모든 조건을 갖추고 CPU 할당을 기다리거나 현재 실행 중임을 나타낸다. 스레드 라이프사이클의 핵심 실행 단계이다.

3. ‘Runnable’ 인터페이스의 ‘run()’ 메소드에서 ‘InterruptedException’ 같은 Checked Exception을 외부에 던질 수 없는 주된 이유는?
   - **오버라이딩 규칙 상 부모 메소드가 선언하지 않은 Checked Exception은 자식 메소드에서 던질 수 없기 때문**
   - ‘Runnable’의 ‘run’ 메소드는 Checked Exception을 선언하지 않았다. 자바 오버라이딩 규칙에 따라, 자식 메소드는 부모가 선언하지 않은 Checked Exception을 던질 수 없다.

4. 어떤 스레드 A가 다른 스레드 B의 ‘B.join()’ 메소드를 호출했을 때, 스레드 A는 어떻게 되는지?
   - **스레드 B가 종료될 때까지 기다린다.**
   - ‘join()’을 호출한 스레드 A는 대상 스레드 B가 자신의 작업을 모두 마치고 종료될 때까지 실행을 멈추고 기다린다. 다른 스레드의 완료를 기다릴 때 사용한다.

5. ‘thread.join()’ 메소드와 ‘thread.join(long milliseconds)’ 메소드의 가장 큰 차이점은?
   - **하나는 대상 스레드의 작업 완료를 무기한 기다리고, 다른 하나는 지정된 시간만큼만 기다린다.**
   - ‘join()’은 대상 스레드가 끝날 때까지 무한히 기다리는 반면, ‘join(millis)’는 지정된 시간 동안만 기다린다. 시간 초과 시 기다림을 멈추고 다음 코드를 실행한다.


| 학습 내용 | 자동차 경주 적용 예시 | 실제 코드/ 행동 예시 |
| --- | --- | --- |
| **NEW 상태** | 각 자동차(Car)가 생성만 되고 아직 출발하지 않은 단계. 즉, new Thread(car)로 객체는 만들어졌지만 레이스가 시작되지 않은 상태. | Thread t1 = new Thread(new Car(”pobi”)); |
| **RUNNABLE 상태** | 레이스가 “출발” 신호로 start() 호출될 때. 각 Car 스레드가 CPU 할당을 기다리거나 실제로 실행 중 | t1.start(); |
| **join() 사용** | RaceController가 “모든 자동차가 완주할 때까지 기다린다.” 즉, 메인 스레드가 모든 Car 스레드의 완료를 기다림. | for(Thread t : threads) {       t. join(); }                              printResults(); // 모든 차가 완주하면 결과 출력 |
| **join(long millis)** | “경주 제한 시간”을 설정할 수 있다. 일정 시간만 기다리고, 아직 안 끝난 차는 완주 실패 처리 가능 | t.join(5000); // 5초 안에 완주 못하면 탈락 |
| **스레드 생명 주기                (NEW → RUNNABLE → TERNIMATED)**     | 각 Car 스레드는 레이스 시작 시 RUNNABLE, 주행이 끝나면 TERNIMATED, 이 생명 주기로 흐름을 관리할 수 있다. | 상태 모니터링 스레드를 추가해서 각 Car 스레드 상태를 주기적으로 출력 |